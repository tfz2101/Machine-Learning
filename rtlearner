"""
A simple wrapper for linear regression.  (c) 2015 Tucker Balch
"""

import numpy as np
import pandas as pd

class PERT(object):
    def __init__(self):
        pass


    def split(self,data,start, end, candidates, givenCol = "null"):

        if givenCol == "null":
            colSplit = givenCol
        else:
            colSplit = np.random.choice(candidates)

        print("colSplit")
        print(colSplit)

        elements = np.random.choice(range(start,end),2, replace=False)
        print('elements')
        print(elements)

        print(data[colSplit])
        print('element1')
        print(data.ix[elements[0],colSplit])
        print('element2')
        print(data.ix[elements[1],colSplit])
        mean = (data.ix[elements[0],colSplit]+data.ix[elements[1],colSplit])/2
        print(mean)
        newCol = colSplit + "_split"
        for i in range(start, (end+1)):
            #print('iteration')
            #print(data.ix[i,colSplit])
            if data.ix[i,colSplit] >= mean:
                data.ix[i,newCol]=1
            else:
                data.ix[i,newCol]=0


        data = data.sort_values(colSplit, axis=0, ascending=False)
        splitInd = data[newCol].sum()
        split1 = data.iloc[0:(splitInd-1),:]
        split1 = pd.DataFrame(split1.as_matrix(), columns=split1.columns.values)
        split2 = data.iloc[splitInd:data.shape[0],:]
        split2 = pd.DataFrame(split2.as_matrix(),columns=split2.columns.values)
        print('split11111')
        print(split1)
        splitInfo = [colSplit,mean]
        return split1, split2, splitInfo


class Node(object):
    def __init__(self, column='Null',mean=0, aboveNode=None, belowNode=None):
        self.column = column
        self.mean = mean
        self.aboveNode = aboveNode
        self.belowNode = belowNode

    def get_next(self, value):
        out = np.nan
        if value >= self.mean:
            out = self.aboveNode

        else:
            out = self.belowNode
        return out

class RTLearner(object):

    def __init__(self, leaf_size=1, verbose = False):
        self.leaf_size = leaf_size
        self.verbose = verbose

    def getPDData(self):
        data = pd.read_csv("L:\OMSCS\MLT\ML4T_2016Fall-master\mc3_p1\Data\winequality-white.csv",sep=',')
        data =  pd.DataFrame(data)

        return data

    def addEvidence(self,dataX=0,dataY=0):
        """
        @summary: Add training data to learner
        @param dataX: X values of data to add
        @param dataY: the Y training values
        """
        data = self.getPDData()
        dt = PERT()
        n = Node()
        candidates = data.columns.values
        candidates =  np.delete(candidates,len(candidates)-1)
        print("candidates")
        print(candidates)

        dataObj = [data]



        for i in range(0,1):
            colSplit = np.random.choice(candidates)
            newdataobj = []
            for obj in dataObj:

                df1, df2, node = dt.split(obj,0,obj.shape[0]-1,candidates, colSplit)
                if df1.shape[0] < self.leaf_size or df2.shape[0] < self.leaf_size:
                    bignp = np.concatenate((df1.as_matrix(),df2.as_matrix()),axis=0)
                    bigdf =pd.DataFrame(bignp, columns = df1.columns.values)
                    print('bigdf')
                    print(bigdf)
                    newdataobj.append(bigdf)
                else:
                    newdataobj.append(df1)
                    newdataobj.append(df2)

            dataObj =  newdataobj
            candidates = np.extract(candidates!=node[0],candidates)
            candidates =  candidates.tolist()

            print('candidates')
            print(candidates)
            print(dataObj)


    def query(self,points):
        """
        @summary: Estimate a set of test points given the model we built.
        @param points: should be a numpy array with each row corresponding to a specific query.
        @returns the estimated values according to the saved model.
        """
        return (self.model_coefs[:-1] * points).sum(axis = 1) + self.model_coefs[-1]

'''
if __name__=="__main__":
    print "the secret clue is 'zzyzx'"
'''

test = RTLearner(leaf_size=4000)
test.addEvidence()
